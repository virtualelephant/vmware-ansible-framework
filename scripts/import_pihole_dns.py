#!/usr/bin/env python3
"""
Pi-hole DNS Record Importer
===========================

Applies **A/AAAA** and **CNAME** records from a YAML file (generated by ``extract_pihole_dns.py``)
to one or more **Pi-hole v6+** instances using the REST API.

Enables **bidirectional GitOps**:
1. Extract → Git
2. Edit → Apply

Features
--------
- Full CRUD: create, update, delete
- Idempotent: only applies changes
- Dry-run mode for safety
- Conflict resolution (keep local, keep file, fail)
- Supports multiple Pi-hole targets
- Detailed diff reporting
- Secure auth with retry logic
- MkDocs-compatible docstring

Usage
-----
.. code-block:: bash

    # Apply from YAML to Pi-hole
    python apply_pihole_dns.py \
        --input dns_records.yaml \
        --servers ns1.home.virtualelephant.com:pass1,ns2.home.virtualelephant.com:pass2 \
        --dry-run

    # Real apply
    python apply_pihole_dns.py --input dns_records.yaml --servers ...

Author
------
Your Name <you@example.com>

License
-------
MIT
"""

from __future__ import annotations

import argparse
import logging
import sys
from typing import Dict, List, Tuple, Optional, Set

import requests
import yaml
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# --------------------------------------------------------------------------- #
# Logging
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Constants
# --------------------------------------------------------------------------- #
API_AUTH_ENDPOINT = "/auth"
API_HOSTS_ENDPOINT = "/config/dns/hosts"
API_CNAMES_ENDPOINT = "/config/dns/cnames"

DEFAULT_TIMEOUT = 10
DEFAULT_RETRIES = 3


# --------------------------------------------------------------------------- #
# Pi-hole API Client (Reused from Extractor)
# --------------------------------------------------------------------------- #
class PiHoleAPI:
    def __init__(self, base_url: str, password: str, timeout: int = DEFAULT_TIMEOUT):
        self.base_url = base_url.rstrip("/")
        self.password = password
        self.timeout = timeout
        self.session = requests.Session()

        retry = Retry(
            total=DEFAULT_RETRIES,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST", "PUT", "DELETE"],
        )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)

        self._sid: Optional[str] = None

    def _auth(self) -> str:
        url = f"{self.base_url}{API_AUTH_ENDPOINT}"
        payload = {"password": self.password}
        try:
            r = self.session.post(url, json=payload, timeout=self.timeout)
            r.raise_for_status()
            sid = r.json().get("sid")
            if not sid:
                raise ValueError("No session ID")
            return sid
        except requests.RequestException as e:
            raise RuntimeError(f"Auth failed: {e}") from e

    @property
    def sid(self) -> str:
        if not self._sid:
            self._sid = self._auth()
        return self._sid

    def _headers(self) -> Dict[str, str]:
        return {"X-FTL-SID": self.sid}

    def get_hosts(self) -> Dict[str, str]:
        url = f"{self.base_url}{API_HOSTS_ENDPOINT}"
        r = self.session.get(url, headers=self._headers(), timeout=self.timeout)
        r.raise_for_status()
        data = r.json()
        result = {}
        for entry in data:
            parts = entry.strip().split(maxsplit=1)
            if len(parts) == 2:
                ip, host = parts
                result[host] = ip
        return result

    def get_cnames(self) -> Dict[str, str]:
        url = f"{self.base_url}{API_CNAMES_ENDPOINT}"
        r = self.session.get(url, headers=self._headers(), timeout=self.timeout)
        r.raise_for_status()
        data = r.json()
        return {rec["domain"]: rec["target"] for rec in data if "domain" in rec and "target" in rec}

    def upsert_host(self, ip: str, hostname: str, dry_run: bool = False) -> bool:
        payload = {"value": f"{ip} {hostname}"}
        url = f"{self.base_url}{API_HOSTS_ENDPOINT}"
        method = self.session.put if dry_run else self.session.post
        try:
            r = method(url, json=payload, headers=self._headers(), timeout=self.timeout)
            if r.status_code in (200, 201):
                return True
            elif r.status_code == 400:
                logger.debug("Host entry invalid or duplicate: %s", payload)
                return False
            else:
                logger.error("Failed to upsert host: %s", r.text)
                return False
        except requests.RequestException as e:
            logger.error("Request failed: %s", e)
            return False

    def delete_host(self, ip: str, hostname: str, dry_run: bool = False) -> bool:
        encoded = f"{ip}%20{hostname}"
        url = f"{self.base_url}{API_HOSTS_ENDPOINT}/{encoded}"
        try:
            r = self.session.delete(url, headers=self._headers(), timeout=self.timeout) if not dry_run else None
            return r.status_code == 204 if r else True
        except requests.RequestException:
            return False

    def upsert_cname(self, domain: str, target: str, dry_run: bool = False) -> bool:
        payload = {"domain": domain, "target": target}
        url = f"{self.base_url}{API_CNAMES_ENDPOINT}"
        method = self.session.put if dry_run else self.session.post
        try:
            r = method(url, json=payload, headers=self._headers(), timeout=self.timeout)
            return r.status_code in (200, 201)
        except requests.RequestException:
            return False

    def delete_cname(self, domain: str, dry_run: bool = False) -> bool:
        encoded = domain.replace(".", "%2E")
        url = f"{self.base_url}{API_CNAMES_ENDPOINT}/{encoded}"
        try:
            r = self.session.delete(url, headers=self._headers(), timeout=self.timeout) if not dry_run else None
            return r.status_code == 204 if r else True
        except requests.RequestException:
            return False


# --------------------------------------------------------------------------- #
# Diff & Apply Logic
# --------------------------------------------------------------------------- #
def compute_diff(
    current: Dict[str, str], desired: Dict[str, str], record_type: str
) -> Tuple[Set[str], Set[Tuple[str, str]], Set[str]]:
    current_set = set(current.keys())
    desired_set = set(desired.keys())

    to_add = desired_set - current_set
    to_update = {
        host for host in desired_set & current_set if desired[host] != current[host]
    }
    to_delete = current_set - desired_set

    return to_add, to_update, to_delete


def apply_records(
    api: PiHoleAPI,
    desired_aaaa: Dict[str, str],
    desired_cname: Dict[str, str],
    dry_run: bool = False,
    conflict_policy: str = "file",
) -> Tuple[int, int]:
    changes = 0
    errors = 0

    # --- A/AAAA ---
    current_aaaa = api.get_hosts()
    add_aaaa, update_aaaa, delete_aaaa = compute_diff(current_aaaa, desired_aaaa, "A/AAAA")

    for host in delete_aaaa:
        ip = current_aaaa[host]
        if dry_run:
            logger.info("[DRY-RUN] Would delete A/AAAA: %s -> %s", host, ip)
        else:
            if api.delete_host(ip, host, dry_run=False):
                logger.info("Deleted A/AAAA: %s -> %s", host, ip)
                changes += 1
            else:
                logger.error("Failed to delete A/AAAA: %s", host)
                errors += 1

    for host in add_aaaa:
        ip = desired_aaaa[host]
        if dry_run:
            logger.info("[DRY-RUN] Would add A/AAAA: %s -> %s", host, ip)
        else:
            if api.upsert_host(ip, host):
                logger.info("Added A/AAAA: %s -> %s", host, ip)
                changes += 1
            else:
                errors += 1

    for host in update_aaaa:
        new_ip = desired_aaaa[host]
        old_ip = current_aaaa[host]
        if dry_run:
            logger.info("[DRY-RUN] Would update A/AAAA: %s %s → %s", host, old_ip, new_ip)
        else:
            if api.delete_host(old_ip, host) and api.upsert_host(new_ip, host):
                logger.info("Updated A/AAAA: %s %s → %s", host, old_ip, new_ip)
                changes += 1
            else:
                errors += 1

    # --- CNAME ---
    current_cname = api.get_cnames()
    add_cname, update_cname, delete_cname = compute_diff(current_cname, desired_cname, "CNAME")

    for domain in delete_cname:
        if dry_run:
            logger.info("[DRY-RUN] Would delete CNAME: %s", domain)
        else:
            if api.delete_cname(domain):
                logger.info("Deleted CNAME: %s", domain)
                changes += 1
            else:
                errors += 1

    for domain in add_cname:
        target = desired_cname[domain]
        if dry_run:
            logger.info("[DRY-RUN] Would add CNAME: %s -> %s", domain, target)
        else:
            if api.upsert_cname(domain, target):
                logger.info("Added CNAME: %s -> %s", domain, target)
                changes += 1
            else:
                errors += 1

    for domain in update_cname:
        new_target = desired_cname[domain]
        old_target = current_cname[domain]
        if dry_run:
            logger.info("[DRY-RUN] Would update CNAME: %s %s → %s", domain, old_target, new_target)
        else:
            if api.delete_cname(domain) and api.upsert_cname(domain, new_target):
                logger.info("Updated CNAME: %s %s → %s", domain, old_target, new_target)
                changes += 1
            else:
                errors += 1

    return changes, errors


# --------------------------------------------------------------------------- #
# CLI
# --------------------------------------------------------------------------- #
def parse_servers_arg(arg: str) -> List[Tuple[str, str]]:
    servers = []
    for part in arg.split(","):
        part = part.strip()
        if ":" not in part:
            raise ValueError(f"Invalid format: {part}")
        url_or_host, password = part.rsplit(":", 1)
        if not url_or_host.startswith("http"):
            url_or_host = f"http://{url_or_host}/admin/api"
        else:
            url_or_host = url_or_host.rstrip("/") + "/admin/api"
        servers.append((url_or_host, password))
    return servers


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Apply DNS records from YAML to Pi-hole",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("--input", "-i", type=str, required=True, help="Input YAML file")
    parser.add_argument("--servers", type=str, required=True, help="Comma-separated host:pass or url:pass")
    parser.add_argument("--dry-run", action="store_true", help="Show changes without applying")
    parser.add_argument("--verbose", "-v", action="store_true", help="Debug logging")
    parser.add_argument(
        "--conflict-policy",
        choices=["file", "local", "fail"],
        default="file",
        help="How to handle conflicts (default: file wins)",
    )

    args = parser.parse_args()
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Load YAML
    try:
        with open(args.input, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        desired_aaaa = data.get("a_aaaa", {})
        desired_cname = data.get("cname", {})
        logger.info("Loaded %d A/AAAA and %d CNAME records from %s",
                    len(desired_aaaa), len(desired_cname), args.input)
    except Exception as e:
        logger.error("Failed to load YAML: %s", e)
        return 1

    # Parse servers
    try:
        servers = parse_servers_arg(args.servers)
    except ValueError as e:
        logger.error("Invalid server format: %s", e)
        return 1

    total_changes = 0
    total_errors = 0

    for base_url, password in servers:
        server_label = base_url.split("//")[-1].split("/")[0]
        logger.info("Applying to %s...", server_label)
        try:
            api = PiHoleAPI(base_url, password)
            changes, errors = apply_records(
                api, desired_aaaa, desired_cname, dry_run=args.dry_run, conflict_policy=args.conflict_policy
            )
            total_changes += changes
            total_errors += errors
            logger.info("Applied to %s: %d changes, %d errors", server_label, changes, errors)
        except Exception as e:
            logger.error("Failed on %s: %s", server_label, e)
            total_errors += 1

    logger.info("Summary: %d total changes, %d total errors", total_changes, total_errors)
    return 0 if total_errors == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
